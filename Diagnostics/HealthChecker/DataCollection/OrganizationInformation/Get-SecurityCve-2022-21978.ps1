# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

. $PSScriptRoot\..\..\..\..\Shared\ErrorMonitorFunctions.ps1
# Check within each domain if we are vulnerable to CVE-2022-21978
function Get-SecurityCve-2022-21978 {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory = $true)]
        [object]$DomainsAcls,

        [Parameter(Mandatory = $true)]
        [object]$ExchangeWellKnownSecurityGroups,

        [Parameter(Mandatory = $true)]
        [ValidateSet("2013", "2016", "2019")]
        [string]$ExchangeSchemaLevel,

        [Parameter(Mandatory = $true)]
        [bool]$SplitADPermissions
    )
    begin {

        function NewMatchingEntry {
            param(
                [ValidateSet("Domain", "AdminSDHolder")]
                [string]$TargetObject,
                [string]$ObjectTypeGuid,
                [string]$InheritedObjectType
            )

            return [PSCustomObject]@{
                TargetObject        = $TargetObject
                ObjectTypeGuid      = $ObjectTypeGuid
                InheritedObjectType = $InheritedObjectType
            }
        }

        function NewGroupEntry {
            param(
                [string]$Name,
                [object[]]$MatchingEntries
            )

            return [PSCustomObject]@{
                Name     = $Name
                Sid      = $null
                AceEntry = $MatchingEntries
            }
        }

        # Computer Class GUID
        $computerClassGUID = "bf967a86-0de6-11d0-a285-00aa003049e2"

        # userCertificate GUID
        $userCertificateGUID = "bf967a7f-0de6-11d0-a285-00aa003049e2"

        # managedBy GUID
        $managedByGUID = "0296c120-40da-11d1-a9c0-0000f80367c1"

        $writePropertyRight = [System.DirectoryServices.ActiveDirectoryRights]::WriteProperty
        $denyType = [System.Security.AccessControl.AccessControlType]::Deny
        $inheritanceAll = [System.DirectoryServices.ActiveDirectorySecurityInheritance]::All

        if ($ExchangeSchemaLevel -eq "2013") {
            $objectVersionSchemaValueMin = 13238
        } else {
            # Exchange 2016 and 2019 have the same MESO objectVersion Value
            $objectVersionSchemaValueMin = 13243
        }

        $groupLists = @(
        (NewGroupEntry "Exchange Servers" @(
            (NewMatchingEntry -TargetObject "Domain" -ObjectTypeGuid $userCertificateGUID -InheritedObjectType $computerClassGUID)
            )),

        (NewGroupEntry "Exchange Windows Permissions" @(
            (NewMatchingEntry -TargetObject "Domain" -ObjectTypeGuid $managedByGUID -InheritedObjectType $computerClassGUID)
            )))

        Write-Verbose "Calling: $($MyInvocation.MyCommand)"
        $domainResults = New-Object 'System.Collections.Generic.List[object]'
    } process {
        # Set the SID on the GroupList
        foreach ($group in $groupLists) {
            $wkObject = $ExchangeWellKnownSecurityGroups | Where-Object { $_.WellKnownName -eq $group.Name }

            if ($null -ne $wkObject) {
                $group.Sid = $wkObject.Sid
            }
        }

        # Loop through each domain and determine if they are secure or not.
        foreach ($domain in $DomainsAcls) {

            $domainName = $domain.DomainName
            Write-Verbose "Checking Domain $domainName"
            $domainAcl = ($domain.Permissions | Where-Object { $_.DN -eq $domain.DomainDN }).Acl
            $adminSdHolderAcl = ($domain.Permissions | Where-Object { $_.DN -eq "CN=AdminSDHolder,CN=System,$($domain.DomainDN)" }).Acl
            $unknownDomain = $domain.DomainDN -eq "Unknown"

            $fallbackLogic = $null -eq $domainAcl -or
            $null -eq $domainAcl.Access -or
            $null -eq $adminSdHolderAcl -or
            $null -eq $adminSdHolderAcl.Access -or
            $unknownDomain -or
            $SplitADPermissions

            $aceListResults = New-Object 'System.Collections.Generic.List[object]'

            if (-not ($fallbackLogic)) {
                # Truly check the ACE in the ACL

                foreach ($group in $groupLists) {
                    Write-Verbose "Looking Ace Entries for the group: $($group.Name)"

                    foreach ($entry in $group.AceEntry) {
                        Write-Verbose "Trying to find the entry GUID: $($entry.ObjectTypeGuid)"
                        if ($entry.TargetObject -eq "AdminSDHolder") {
                            $objectAcl = $adminSdHolderAcl
                            $objectDN = $adminSdHolderDN
                        } else {
                            $objectAcl = $domainAcl
                            $objectDN = $domainDN
                        }
                        Write-Verbose "ObjectDN: $objectDN"

                        try {

                            # We need to pass an IdentityReference object to the constructor
                            $groupIdentityRef = New-Object System.Security.Principal.SecurityIdentifier($group.Sid)

                            $ace = New-Object System.DirectoryServices.ActiveDirectoryAccessRule($groupIdentityRef, $writePropertyRight, $denyType, $entry.ObjectTypeGuid, $inheritanceAll, $entry.InheritedObjectType)

                            $checkAce = $objectAcl.Access.Where({
                            ($_.ActiveDirectoryRights -eq $ace.ActiveDirectoryRights) -and
                            ($_.InheritanceType -eq $ace.InheritanceType) -and
                            ($_.ObjectType -eq $ace.ObjectType) -and
                            ($_.InheritedObjectType -eq $ace.InheritedObjectType) -and
                            ($_.ObjectFlags -eq $ace.ObjectFlags) -and
                            ($_.AccessControlType -eq $ace.AccessControlType) -and
                            ($_.IsInherited -eq $ace.IsInherited) -and
                            ($_.InheritanceFlags -eq $ace.InheritanceFlags) -and
                            ($_.PropagationFlags -eq $ace.PropagationFlags) -and
                            ($_.IdentityReference -eq $ace.IdentityReference.Translate([System.Security.Principal.NTAccount]))
                                })

                            $checkPass = $checkAce.Count -gt 0
                            Write-Verbose "Ace Result Check Passed: $checkPass"

                            $aceListResults.Add([PSCustomObject]@{
                                    ObjectDN  = $objectDN
                                    CheckPass = $checkPass
                                })
                        } catch {
                            Write-Verbose "Failed to do ACE comparison"
                            Invoke-CatchActions
                        }
                    }
                }
            }

            # should be true in fallback or all ace exists
            $allAcePass = ($aceListResults | Where-Object { $_.CheckPass -eq $false }).Count -eq 0
            $MesoUpdated = $domain.MesoObject.ObjectVersion -ge $objectVersionSchemaValueMin
            $domainPassed = $allAcePass -and $MesoUpdated -and (-not $unknownDomain)
            $domainResults.Add([PSCustomObject]@{
                    DomainName    = $domainName
                    DomainPassed  = $domainPassed
                    MesoUpdated   = $MesoUpdated
                    AllAcePass    = $allAcePass
                    UnknownDomain = $unknownDomain
                })
        }
    } end {
        return $domainResults
    }
}
